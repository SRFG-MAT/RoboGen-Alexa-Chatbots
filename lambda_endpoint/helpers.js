
//-------------------------------------------------------------------------
// external helper functions for Node.js (autogenerated stuff)
//-------------------------------------------------------------------------
module.exports = {
    
    //-------------------------------------------------------------------------
    // functions for basic outputs
    //-------------------------------------------------------------------------
    supportsDisplay: function(caller) { // check if device has a display
    	var hasDisplay = 
    	caller.event.context &&
    	caller.event.context.System &&
    	caller.event.context.System.device &&
    	caller.event.context.System.device.supportedInterfaces &&
    	caller.event.context.System.device.supportedInterfaces.Display;
    	
    	return hasDisplay;
    },
    
    output_EmitandDisplay: function(object, display, textWithDisplay, textWithoutDisplay, welcomeReprompt, cardNumber)
    {
    	if(this.supportsDisplay(object))
    	{
    		var template = null; 
    		
    		switch(cardNumber)
    		{
    		    case 1: 
    		    	template = display.buildTemplate_RoboGenBasicCard_Intro(textWithDisplay);
    		    	break;
    		    case 2: 
    		    	template = display.buildTemplate_RoboGenBasicCard_Stress(textWithDisplay);
    		    	break;
    		    case 3:
    		        template = display.buildTemplate_RoboGenBasicCard_Sport(textWithDisplay);
    		    	break;
    		    case 4:
    		        template = display.buildTemplate_RoboGenBasicCard_Error(textWithDisplay);
    		    	break;
    		    default:
    		        template = display.buildTemplate_RoboGenBasicCard_Error(textWithDisplay);
    		    	break;
    		}   
    		
    	    object.response.speak(textWithDisplay).renderTemplate(template).shouldEndSession(null).listen(welcomeReprompt);
    	    object.emit(':responseReady');
    	}
    	else
    	{
    	    object.emit(':ask', textWithoutDisplay, textWithoutDisplay);
    	}
    },
    
    //-------------------------------------------------------------------------
    // function for url resolving
    //-------------------------------------------------------------------------
    httpsGet: function(url_host, url_path, callback) {
        
        var https = require('https'); // info: use http instead of https if needed
        
        var options = {
            host: url_host,
            path: url_path
        }
        var request = https.request(options, function (res) {
            var data = '';
            res.on('data', function (chunk) {
                data += chunk;
            });
            res.on('end', function () {
                console.log(data);
                
                var startIDX = data.indexOf("<div class=\"entry-content\">") + "<div class=\"entry-content\">".length;
                var endIDX = data.indexOf("</div><!-- .entry-content -->");
                var substring = data.substring(startIDX, endIDX);
                
                substring = substring.replace(/(\r\n|\n|\r)/gm, " "); // replace all new lines
                
                // needed for sport
                substring = substring.split('&#8220;').join(' '); // " open
                substring = substring.split('&#8221;').join(' '); // " close
                substring = substring.split('&#8217;').join(' ');
                substring = substring.split('&#8230;').join(' ');
                substring = substring.split('.&nbsp;').join(': ');
                
                // needed for both
                substring = substring.split('<p>').join('');
                substring = substring.split('</p>').join('');
                substring = substring.split('<ul>').join('');
                substring = substring.split('</ul>').join('');
                substring = substring.split('<li>').join('Aufz√§hlungspunkt: ');
                substring = substring.split('</li>').join('');
                
                console.log(substring);
                callback(substring);
            });
        });
        request.on('error', function (e) {
            console.log(e.message);
            callback("BAD");
        });
        request.end();
    },
    
    //-------------------------------------------------------------------------
    // functions for logic, phrases and slots
    //-------------------------------------------------------------------------
    resolveCanonical: function(slot){ //returns the slot value if a synonyms is provided
    
    	let canonical;
        try{
    		canonical = slot.resolutions.resolutionsPerAuthority[0].values[0].value.name;
    	}catch(err){
    	    console.log(err.message);
    	    canonical = slot.value;
    	};
    	return canonical;
    },
    
    delegateSlotCollection: function (object){
        
        console.log("in delegateSlotCollection");
        console.log("current dialogState: "+ object.event.request.dialogState);
        
        if (object.event.request.dialogState === "STARTED") {
          console.log("in Beginning");
    	  let updatedIntent= null;
    	  
    	  if(object.isOverridden()) {
    			return;
    		}
    		object.handler.response = this.buildSpeechletResponse({
    			sessionAttributes: object.attributes,
    			directives: this.getDialogDirectives('Dialog.Delegate', updatedIntent, null),
    			shouldEndSession: false
    		});
    		object.emit(':responseReady', updatedIntent);
    		
        } else if (object.event.request.dialogState !== "COMPLETED") {
          console.log("in not completed");
  
    		if(object.isOverridden()) {
    			return;
    		}
    		object.handler.response = this.buildSpeechletResponse({
    			sessionAttributes: object.attributes,
    			directives: this.getDialogDirectives('Dialog.Delegate', null, null),
    			shouldEndSession: false
    		});
    		object.emit(':responseReady');
    		
        } else {
          console.log("in completed");
          console.log("returning: "+ JSON.stringify(object.event.request.intent));
          return object.event.request.intent;
        }
    },
    
    randomPhrase: function (array) {
        let i = 0;
        i = Math.floor(Math.random() * array.length);
        return(array[i]);
    },
    
    isSlotValid: function(request, slotName){
        let slot = request.intent.slots[slotName];
        let slotValue;

        if (slot && slot.value) { //we have a value in the slot
            slotValue = slot.value.toLowerCase();
            return slotValue;
        } 
        else {return false;} //we didn't get a value in the slot.
   },

    //-------------------------------------------------------------------------
    // These functions are here to allow dialog directives to work 
    // with SDK versions prior to 1.0.9
    // (will be removed once Lambda templates are updated with the latest SDK)
    //-------------------------------------------------------------------------
    createSpeechObject: function(optionsParam) {
        if (optionsParam && optionsParam.type === 'SSML') {
            return {
                type: optionsParam.type,
                ssml: optionsParam['speech']
            };
        } else {
            return {
                type: optionsParam.type || 'PlainText',
                text: optionsParam['speech'] || optionsParam
            };
        }
    },
    
    buildSpeechletResponse: function(options) {
        let alexaResponse = {
            shouldEndSession: options.shouldEndSession
        };
    
        if (options.output) {
            alexaResponse.outputSpeech = this.createSpeechObject(options.output);
        }
    
        if (options.reprompt) {
            alexaResponse.reprompt = {
                outputSpeech: this.createSpeechObject(options.reprompt)
            };
        }
    
        if (options.directives) {
            alexaResponse.directives = options.directives;
        }
    
        if (options.cardTitle && options.cardContent) {
            alexaResponse.card = {
                type: 'Simple',
                title: options.cardTitle,
                content: options.cardContent
            };
    
            if(options.cardImage && (options.cardImage.smallImageUrl || options.cardImage.largeImageUrl)) {
                alexaResponse.card.type = 'Standard';
                alexaResponse.card['image'] = {};
    
                delete alexaResponse.card.content;
                alexaResponse.card.text = options.cardContent;
    
                if(options.cardImage.smallImageUrl) {
                    alexaResponse.card.image['smallImageUrl'] = options.cardImage.smallImageUrl;
                }
    
                if(options.cardImage.largeImageUrl) {
                    alexaResponse.card.image['largeImageUrl'] = options.cardImage.largeImageUrl;
                }
            }
        } else if (options.cardType === 'LinkAccount') {
            alexaResponse.card = {
                type: 'LinkAccount'
            };
        } else if (options.cardType === 'AskForPermissionsConsent') {
            alexaResponse.card = {
                type: 'AskForPermissionsConsent',
                permissions: options.permissions
            };
        }
    
        let returnResult = {
            version: '1.0',
            response: alexaResponse
        };
    
        if (options.sessionAttributes) {
            returnResult.sessionAttributes = options.sessionAttributes;
        }
        return returnResult;
    },
    
    getDialogDirectives: function(dialogType, updatedIntent, slotName) {
        let directive = {
            type: dialogType
        };
    
        if (dialogType === 'Dialog.ElicitSlot') {
            directive.slotToElicit = slotName;
        } else if (dialogType === 'Dialog.ConfirmSlot') {
            directive.slotToConfirm = slotName;
        }
    
        if (updatedIntent) {
            directive.updatedIntent = updatedIntent;
        }
        return [directive];
    }
}